\chapter{Various}

\section{Misc. algorithms}
	\kactlimport{Dates.h}
	\kactlimport{MultisetHash.h}
	\kactlimport{Rand.h}

\section{Dynamic programming}
	\kactlimport{KnuthDP.h}
	\kactlimport{DivideAndConquerDP.h}

\section{Optimization tricks}
	\subsection{Bit hacks}
		\begin{itemize}
			\item \verb@for (int x = m; x; x = (x - 1)&m ) { ... }@ loops over all subset masks of \texttt{m} (except 0).
			\item \verb@c = x&-x, r = x+c; (((r^x) >> 2)/c) | r@ is the next number after \texttt{x} with the same number of bits set.
			\item \verb@rep(b,0,K) rep(i,0,(1 << K))@ \\ \verb@  if (i & 1 << b) D[i] += D[i^(1 << b)];@ computes all sums of subsets.
		\end{itemize}
	\subsection{Pragmas}
		\begin{itemize}
			\item \lstinline{#pragma GCC optimize ("Ofast")} will make GCC auto-vectorize loops and optimizes floating points better.
			\item \lstinline{#pragma GCC target ("avx2")} can double performance of vectorized code, but causes crashes on old machines.
			\item \lstinline{#pragma GCC target("bmi,bmi2,popcnt,lzcnt")} improve bit operations.
			\item \lstinline{#pragma GCC optimize("unroll-loops")} self explanatory.
		\end{itemize}
